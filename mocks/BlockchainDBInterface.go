// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	ed25519 "golang.org/x/crypto/ed25519"
	rsa "crypto/rsa"

	mock "github.com/stretchr/testify/mock"

	shared "github.com/thrylos-labs/thrylos/shared"
)

// BlockchainDBInterface is an autogenerated mock type for the BlockchainDBInterface type
type BlockchainDBInterface struct {
	mock.Mock
}

// AddTransaction provides a mock function with given fields: tx
func (_m *BlockchainDBInterface) AddTransaction(tx shared.Transaction) error {
	ret := _m.Called(tx)

	if len(ret) == 0 {
		panic("no return value specified for AddTransaction")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(shared.Transaction) error); ok {
		r0 = rf(tx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddUTXO provides a mock function with given fields: utxo
func (_m *BlockchainDBInterface) AddUTXO(utxo shared.UTXO) error {
	ret := _m.Called(utxo)

	if len(ret) == 0 {
		panic("no return value specified for AddUTXO")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(shared.UTXO) error); ok {
		r0 = rf(utxo)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BeginTransaction provides a mock function with given fields:
func (_m *BlockchainDBInterface) BeginTransaction() (*shared.TransactionContext, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for BeginTransaction")
	}

	var r0 *shared.TransactionContext
	var r1 error
	if rf, ok := ret.Get(0).(func() (*shared.TransactionContext, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *shared.TransactionContext); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*shared.TransactionContext)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CommitTransaction provides a mock function with given fields: txn
func (_m *BlockchainDBInterface) CommitTransaction(txn *shared.TransactionContext) error {
	ret := _m.Called(txn)

	if len(ret) == 0 {
		panic("no return value specified for CommitTransaction")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*shared.TransactionContext) error); ok {
		r0 = rf(txn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateAndSignTransaction provides a mock function with given fields: txID, inputs, outputs, privKey
func (_m *BlockchainDBInterface) CreateAndSignTransaction(txID string, inputs []shared.UTXO, outputs []shared.UTXO, privKey *rsa.PrivateKey) (shared.Transaction, error) {
	ret := _m.Called(txID, inputs, outputs, privKey)

	if len(ret) == 0 {
		panic("no return value specified for CreateAndSignTransaction")
	}

	var r0 shared.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(string, []shared.UTXO, []shared.UTXO, *rsa.PrivateKey) (shared.Transaction, error)); ok {
		return rf(txID, inputs, outputs, privKey)
	}
	if rf, ok := ret.Get(0).(func(string, []shared.UTXO, []shared.UTXO, *rsa.PrivateKey) shared.Transaction); ok {
		r0 = rf(txID, inputs, outputs, privKey)
	} else {
		r0 = ret.Get(0).(shared.Transaction)
	}

	if rf, ok := ret.Get(1).(func(string, []shared.UTXO, []shared.UTXO, *rsa.PrivateKey) error); ok {
		r1 = rf(txID, inputs, outputs, privKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUTXO provides a mock function with given fields: id, txID, index, address, amount
func (_m *BlockchainDBInterface) CreateUTXO(id string, txID string, index int, address string, amount int) (shared.UTXO, error) {
	ret := _m.Called(id, txID, index, address, amount)

	if len(ret) == 0 {
		panic("no return value specified for CreateUTXO")
	}

	var r0 shared.UTXO
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, int, string, int) (shared.UTXO, error)); ok {
		return rf(id, txID, index, address, amount)
	}
	if rf, ok := ret.Get(0).(func(string, string, int, string, int) shared.UTXO); ok {
		r0 = rf(id, txID, index, address, amount)
	} else {
		r0 = ret.Get(0).(shared.UTXO)
	}

	if rf, ok := ret.Get(1).(func(string, string, int, string, int) error); ok {
		r1 = rf(id, txID, index, address, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllUTXOs provides a mock function with given fields:
func (_m *BlockchainDBInterface) GetAllUTXOs() (map[string][]shared.UTXO, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAllUTXOs")
	}

	var r0 map[string][]shared.UTXO
	var r1 error
	if rf, ok := ret.Get(0).(func() (map[string][]shared.UTXO, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() map[string][]shared.UTXO); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]shared.UTXO)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBalance provides a mock function with given fields: address, utxos
func (_m *BlockchainDBInterface) GetBalance(address string, utxos map[string]shared.UTXO) (int, error) {
	ret := _m.Called(address, utxos)

	if len(ret) == 0 {
		panic("no return value specified for GetBalance")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(string, map[string]shared.UTXO) (int, error)); ok {
		return rf(address, utxos)
	}
	if rf, ok := ret.Get(0).(func(string, map[string]shared.UTXO) int); ok {
		r0 = rf(address, utxos)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(string, map[string]shared.UTXO) error); ok {
		r1 = rf(address, utxos)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLastBlockData provides a mock function with given fields:
func (_m *BlockchainDBInterface) GetLastBlockData() ([]byte, int, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetLastBlockData")
	}

	var r0 []byte
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func() ([]byte, int, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func() int); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func() error); ok {
		r2 = rf()
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetUTXOs provides a mock function with given fields: address
func (_m *BlockchainDBInterface) GetUTXOs(address string) (map[string][]shared.UTXO, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetUTXOs")
	}

	var r0 map[string][]shared.UTXO
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (map[string][]shared.UTXO, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(string) map[string][]shared.UTXO); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]shared.UTXO)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUTXOsByAddress provides a mock function with given fields: address
func (_m *BlockchainDBInterface) GetUTXOsByAddress(address string) (map[string][]shared.UTXO, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetUTXOsByAddress")
	}

	var r0 map[string][]shared.UTXO
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (map[string][]shared.UTXO, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(string) map[string][]shared.UTXO); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]shared.UTXO)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUTXOsForAddress provides a mock function with given fields: address
func (_m *BlockchainDBInterface) GetUTXOsForAddress(address string) ([]shared.UTXO, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for GetUTXOsForAddress")
	}

	var r0 []shared.UTXO
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]shared.UTXO, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(string) []shared.UTXO); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]shared.UTXO)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUTXOsForUser provides a mock function with given fields: address, utxos
func (_m *BlockchainDBInterface) GetUTXOsForUser(address string, utxos map[string]shared.UTXO) ([]shared.UTXO, error) {
	ret := _m.Called(address, utxos)

	if len(ret) == 0 {
		panic("no return value specified for GetUTXOsForUser")
	}

	var r0 []shared.UTXO
	var r1 error
	if rf, ok := ret.Get(0).(func(string, map[string]shared.UTXO) ([]shared.UTXO, error)); ok {
		return rf(address, utxos)
	}
	if rf, ok := ret.Get(0).(func(string, map[string]shared.UTXO) []shared.UTXO); ok {
		r0 = rf(address, utxos)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]shared.UTXO)
		}
	}

	if rf, ok := ret.Get(1).(func(string, map[string]shared.UTXO) error); ok {
		r1 = rf(address, utxos)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InsertBlock provides a mock function with given fields: data, blockNumber
func (_m *BlockchainDBInterface) InsertBlock(data []byte, blockNumber int) error {
	ret := _m.Called(data, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for InsertBlock")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, int) error); ok {
		r0 = rf(data, blockNumber)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertOrUpdateEd25519PublicKey provides a mock function with given fields: address, ed25519PublicKey
func (_m *BlockchainDBInterface) InsertOrUpdateEd25519PublicKey(address string, ed25519PublicKey []byte) error {
	ret := _m.Called(address, ed25519PublicKey)

	if len(ret) == 0 {
		panic("no return value specified for InsertOrUpdateEd25519PublicKey")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, []byte) error); ok {
		r0 = rf(address, ed25519PublicKey)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertOrUpdatePrivateKey provides a mock function with given fields: address, privateKey
func (_m *BlockchainDBInterface) InsertOrUpdatePrivateKey(address string, privateKey []byte) error {
	ret := _m.Called(address, privateKey)

	if len(ret) == 0 {
		panic("no return value specified for InsertOrUpdatePrivateKey")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, []byte) error); ok {
		r0 = rf(address, privateKey)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RetrieveBlock provides a mock function with given fields: blockNumber
func (_m *BlockchainDBInterface) RetrieveBlock(blockNumber int) ([]byte, error) {
	ret := _m.Called(blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for RetrieveBlock")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(int) ([]byte, error)); ok {
		return rf(blockNumber)
	}
	if rf, ok := ret.Get(0).(func(int) []byte); ok {
		r0 = rf(blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RetrieveEd25519PublicKey provides a mock function with given fields: address
func (_m *BlockchainDBInterface) RetrieveEd25519PublicKey(address string) (ed25519.PublicKey, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for RetrieveEd25519PublicKey")
	}

	var r0 ed25519.PublicKey
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (ed25519.PublicKey, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(string) ed25519.PublicKey); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ed25519.PublicKey)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RetrievePrivateKey provides a mock function with given fields: address
func (_m *BlockchainDBInterface) RetrievePrivateKey(address string) ([]byte, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for RetrievePrivateKey")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]byte, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(string) []byte); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RetrievePublicKeyFromAddress provides a mock function with given fields: address
func (_m *BlockchainDBInterface) RetrievePublicKeyFromAddress(address string) (ed25519.PublicKey, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for RetrievePublicKeyFromAddress")
	}

	var r0 ed25519.PublicKey
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (ed25519.PublicKey, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(string) ed25519.PublicKey); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ed25519.PublicKey)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RollbackTransaction provides a mock function with given fields: txn
func (_m *BlockchainDBInterface) RollbackTransaction(txn *shared.TransactionContext) error {
	ret := _m.Called(txn)

	if len(ret) == 0 {
		panic("no return value specified for RollbackTransaction")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*shared.TransactionContext) error); ok {
		r0 = rf(txn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SanitizeAndFormatAddress provides a mock function with given fields: address
func (_m *BlockchainDBInterface) SanitizeAndFormatAddress(address string) (string, error) {
	ret := _m.Called(address)

	if len(ret) == 0 {
		panic("no return value specified for SanitizeAndFormatAddress")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(address)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendTransaction provides a mock function with given fields: fromAddress, toAddress, amount, privKey
func (_m *BlockchainDBInterface) SendTransaction(fromAddress string, toAddress string, amount int, privKey *rsa.PrivateKey) (bool, error) {
	ret := _m.Called(fromAddress, toAddress, amount, privKey)

	if len(ret) == 0 {
		panic("no return value specified for SendTransaction")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, int, *rsa.PrivateKey) (bool, error)); ok {
		return rf(fromAddress, toAddress, amount, privKey)
	}
	if rf, ok := ret.Get(0).(func(string, string, int, *rsa.PrivateKey) bool); ok {
		r0 = rf(fromAddress, toAddress, amount, privKey)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, int, *rsa.PrivateKey) error); ok {
		r1 = rf(fromAddress, toAddress, amount, privKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetTransaction provides a mock function with given fields: txn, key, value
func (_m *BlockchainDBInterface) SetTransaction(txn *shared.TransactionContext, key []byte, value []byte) error {
	ret := _m.Called(txn, key, value)

	if len(ret) == 0 {
		panic("no return value specified for SetTransaction")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*shared.TransactionContext, []byte, []byte) error); ok {
		r0 = rf(txn, key, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreBlock provides a mock function with given fields: data, blockNumber
func (_m *BlockchainDBInterface) StoreBlock(data []byte, blockNumber int) error {
	ret := _m.Called(data, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for StoreBlock")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, int) error); ok {
		r0 = rf(data, blockNumber)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateUTXOs provides a mock function with given fields: inputs, outputs
func (_m *BlockchainDBInterface) UpdateUTXOs(inputs []shared.UTXO, outputs []shared.UTXO) error {
	ret := _m.Called(inputs, outputs)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUTXOs")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]shared.UTXO, []shared.UTXO) error); ok {
		r0 = rf(inputs, outputs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewBlockchainDBInterface creates a new instance of BlockchainDBInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBlockchainDBInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *BlockchainDBInterface {
	mock := &BlockchainDBInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
